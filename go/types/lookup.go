// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.
// Source: ../../cmd/compile/internal/types2/lookup.go

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// このファイルは、さまざまなフィールドやメソッドの検索機能を実装しています。

package types

// LookupSelectionは、型Tの値に対して、ID Id(pkg, name)を持つフィールドまたはメソッドを選択します。
// addressableが設定されている場合、Tはアドレス可能な変数の型です（これはメソッド検索の場合のみ重要です）。
// Tはnilであってはなりません。
//
// 選択が有効な場合：
//
//   - [Selection.Obj]はフィールド（[Var]）またはメソッド（[Func]）を返します；
//   - [Selection.Indirect]は、フィールドまたはメソッドへのパスにポインタ間接参照があったかどうかを報告します。
//   - [Selection.Index]は、以下で定義されるインデックスシーケンスを返します。
//
// 最後のインデックスエントリは、エントリが見つかった（おそらく埋め込まれた）型における
// フィールドまたはメソッドのインデックスです：
//
//  1. 名前付き型の宣言されたメソッドのリスト；または
//  2. インターフェース型のすべてのメソッド（メソッドセット）のリスト；または
//  3. 構造体型のフィールドのリスト。
//
// より早いインデックスエントリは、見つかったエントリに到達するためにトラバースされた
// 埋め込まれた構造体フィールドのインデックスであり、深度0から開始します。
//
// また、コンポーネントを別々に返す [LookupFieldOrMethod] も参照してください。
func LookupSelection(T Type, addressable bool, pkg *Package, name string) (Selection, bool)

// LookupFieldOrMethodは、T内で指定されたパッケージと名前を持つフィールドまたはメソッドを検索し、
// 対応する*Varまたは*Func、インデックスシーケンス、およびフィールドまたはメソッドへのパスに
// ポインタ間接参照があったかどうかを示すboolを返します。addressableが設定されている場合、
// Tはアドレス可能な変数の型です（メソッド検索の場合のみ重要です）。Tはnilであってはなりません。
//
// 最後のインデックスエントリは、エントリが見つかった（おそらく埋め込まれた）型における
// フィールドまたはメソッドのインデックスです：
//
//  1. 名前付き型の宣言されたメソッドのリスト；または
//  2. インターフェース型のすべてのメソッド（メソッドセット）のリスト；または
//  3. 構造体型のフィールドのリスト。
//
// より早いインデックスエントリは、見つかったエントリに到達するためにトラバースされた
// 埋め込まれた構造体フィールドのインデックスであり、深度0から開始します。
//
// エントリが見つからない場合、nilオブジェクトが返されます。この場合、返される
// インデックスとindirectの値は以下の意味を持ちます：
//
//   - index != nilの場合、インデックスシーケンスは曖昧なエントリを指します
//     （同じ名前が同じ埋め込みレベルで複数回現れた場合）。
//
//   - indirectが設定されている場合、ポインタレシーバー型を持つメソッドが見つかりましたが、
//     実際のレシーバー型からメソッドの形式的なレシーバーベース型へのパスにポインタがなく、
//     レシーバーもアドレス可能ではありませんでした。
//
// 結果を[Selection]として返す [LookupSelection] も参照してください。
func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)

// MissingMethodは、VがTを実装している場合、(nil, false)を返します。そうでない場合、Tに必要な欠落しているメソッドと、欠落しているか、または単に間違った型（ポインタレシーバーまたは間違ったシグネチャ）を返します。
// 非インターフェース型V、またはstaticが設定されている場合、VがTを実装するには、TのすべてのメソッドがVに存在する必要があります。それ以外の場合（Vがインターフェースであり、staticが設定されていない場合）、MissingMethodは、Vにも存在するTのメソッドの型が一致していることだけをチェックします（例：型アサーションx.(T)の場合、xがインターフェース型Vである場合）。
func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)
