// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build goexperiment.jsonv2

// Package jsontextは、RFC 4627, RFC 7159, RFC 7493, RFC 8259, RFC 8785で規定された
// JSONの構文処理を実装します。
// JSONは、ブール値、文字列、数値などのプリミティブ型に加え、
// オブジェクトや配列などの構造化データ型も表現できるシンプルなデータ交換フォーマットです。
//
// このパッケージ（encoding/json/jsontext）は実験的なものであり、
// Go 1の互換性保証の対象ではありません。
// GOEXPERIMENT=jsonv2環境変数を設定してビルドした場合のみ存在します。
// ほとんどのユーザーは[encoding/json]を使用してください。
//
// [Encoder] 型と [Decoder] 型は、JSONトークンや値のストリームをエンコードまたはデコードするために使われます。
//
// # Tokens and Values
//
// JSONトークンは、JSONの基本的な構造要素を指します:
//
//   - JSONリテラル（null, true, false）
//   - JSON文字列（例: "hello, world!"）
//   - JSON数値（例: 123.456）
//   - JSONオブジェクトの開始・終了デリミタ（'{' または '}'）
//   - JSON配列の開始・終了デリミタ（'[' または ']'）
//
// JSONトークンはGoの [Token] 型で表現されます。技術的には、他にも2つの構造文字（':'と','）がありますが、
// これらはJSON文法の構造から存在が推測できるため、[Token] 型としては表現されません。
// 例えば、JSONオブジェクトの名前と値の間には必ず暗黙のコロンが存在します。
//
// JSON値は、完全なJSONデータ単位を指します:
//
//   - JSONリテラル、文字列、数値
//   - JSONオブジェクト（例: `{"name":"value"}`）
//   - JSON配列（例: `[1,2,3,]`）
//
// JSON値はGoの [Value] 型で表現され、値の生テキスト表現を含む[]byteです。
// トークンと値はリテラル、文字列、数値を含む点で重複しますが、
// オブジェクトや配列全体を表現できるのは値のみです。
//
// [Encoder] 型と [Decoder] 型は、シーケンス内の次の [Token] または [Value] を読み書きするメソッドを持ちます。
// これらは状態マシンを維持し、JSONトークンや値の並びが有効なJSONかどうかを検証します。
// [Options] は [NewEncoder] や [NewDecoder] のコンストラクタに渡すことで、エンコード・デコードの構文的挙動を設定できます。
//
// # Terminology
//
// "encode"と"decode"という用語は、JSONの文法に基づいて処理する構文的機能を指します。
// 一方、"marshal"と"unmarshal"という用語は、JSON値の意味をGo値として解釈したり、逆にGo値をJSON値として表現する意味的機能を指します。
// このパッケージ（[jsontext]）はJSONの構文層を扱い、[encoding/json/v2] はJSONの意味層を扱います。
// 構文的なエンコードと意味的なマーシャルの機能を明確に区別することが目的です。
// 例えば、具体的なGo値にマーシャルせずに、JSONトークンのストリームを直接エンコードできます。
// 同様に、具体的なGo値にアンマーシャルせずに、JSONトークンのストリームをデコードできます。
//
// このパッケージではJSONについて説明する際、Goや他の計算機科学の文献で使われる概念と異なる場合がありますが、JSONの用語を使用します。
//
//   - JSONの「object」は名前と値のメンバーの順不同コレクションを指します。
//   - JSONの「array」は要素の順序付きシーケンスを指します。
//   - JSONの「value」はリテラル（null, false, true）、文字列、数値、オブジェクト、配列のいずれかを指します。
//
// 詳細はRFC 8259を参照してください。
//
// # Specifications
//
// 関連する仕様にはRFC 4627, RFC 7159, RFC 7493, RFC 8259, RFC 8785があります。
// 各RFCは一般的に他のRFCのより厳密なサブセットです。厳密さの順に:
//
//   - RFC 4627とRFC 7159はUTF-8の使用を必須とはしていません（推奨のみ）
//     また、オブジェクト名の一意性も必須ではありません（推奨のみ）
//   - RFC 8259はUTF-8の使用を必須としますが、オブジェクト名の一意性は必須ではありません（推奨のみ）
//   - RFC 7493はUTF-8の使用を必須とし、オブジェクト名の一意性も必須とします
//   - RFC 8785は正規表現を定義します。UTF-8の使用を必須とし、
//     オブジェクト名の一意性と特定の順序も必須とします。
//     文字列や数値のフォーマット方法も厳密に規定します。
//
// RFC 4627とRFC 7159の主な違いは、前者がトップレベル値をJSONオブジェクトと配列のみに制限していたのに対し、
// RFC 7159以降のRFCではトップレベル値としてJSONのnull、boolean、文字列、数値も許可しています。
//
// デフォルトでは、このパッケージはRFC 7493に準拠して動作しますが、他のRFC仕様に合わせて設定することも可能です。
// RFC 7493はRFC 8259のより厳密なサブセットであり、完全に準拠しています。
// 特に、RFC 8259が未定義としている動作について、より高い相互運用性を確保するために具体的な選択を行っています。
//
// # Security Considerations
//
// 「セキュリティに関する考慮事項」については [encoding/json/v2] の該当セクションを参照してください。
package jsontext
