// Copyright 2020 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build goexperiment.jsonv2

// Package jsonは、RFC 8259で規定されたJSONのセマンティック処理を実装します。
// JSONは、真偽値、文字列、数値などのプリミティブ型に加え、
// オブジェクトや配列などの構造化データ型も表現できるシンプルなデータ交換フォーマットです。
//
// このパッケージ（encoding/json/v2）は実験的なものであり、
// Go 1 の互換性保証の対象ではありません。
// GOEXPERIMENT=jsonv2 環境変数を設定してビルドした場合のみ存在します。
// ほとんどのユーザーは [encoding/json] を使用してください。
//
// [Marshal] および [Unmarshal] は、Go値を[]byte内のJSONテキストへエンコード・デコードします。
// [MarshalWrite] および [UnmarshalRead] は、[io.Writer] や [io.Reader] を介してJSONテキストを書き込み・読み込みします。
// [MarshalEncode] および [UnmarshalDecode] は、[jsontext.Encoder] や [jsontext.Decoder] を使ってJSONテキストをエンコード・デコードします。
// 各マーシャル・アンマーシャル関数には [Options] を渡すことで、マーシャル・アンマーシャルのセマンティクス（つまりJSONデータとGoデータの対応方法）を設定できます。
// また、[jsontext.Options] を渡すことで、エンコード・デコードの構文的な挙動も設定できます。
//
// JSONのデータ型は、両者の型システム間で最も論理的に近いGoのデータ型へマッピングされます。例えば、
// JSONの真偽値はGoのbool型に、
// JSONの文字列はGoのstring型に、
// JSONの数値はGoのint型、uint型、float型に、
// JSONの配列はGoのスライスまたは配列に、
// JSONのオブジェクトはGoの構造体またはマップに対応します。
// JSONとGoの型システムの対応関係の詳細は [Marshal] および [Unmarshal] のドキュメントを参照してください。
//
// 任意のGo型は、[Marshaler]、[MarshalerTo]、[Unmarshaler]、[UnmarshalerFrom] を実装することで
// JSON表現をカスタマイズできます。
// これにより、Go型の作者は自身の型がJSONとしてどのようにシリアライズされるかを制御できます。
// また、[MarshalFunc]、[MarshalToFunc]、[UnmarshalFunc]、[UnmarshalFromFunc] に一致する関数を実装することで
// 任意の型のJSON表現を指定することもできます。
// これにより、JSON機能の利用者は任意の型がJSONとしてどのようにシリアライズされるかを制御できます。
//
// # JSON Representation of Go structs
//
// Goの構造体は自然にJSONオブジェクトとして表現され、
// 各Go構造体フィールドがJSONオブジェクトのメンバーに対応します。
// マーシャル時は、無視または省略されたフィールドを除き、すべてのGo構造体フィールドが
// 深さ優先で再帰的にJSONオブジェクトのメンバーとしてエンコードされます。
// アンマーシャル時は、JSONオブジェクトのメンバーが対応するGo構造体フィールドへ
// 再帰的にデコードされます。
// 構造体フィールドに一致しないオブジェクトメンバー（「未知のメンバー」とも呼ばれる）は、
// デフォルトでは無視されますが、[RejectUnknownMembers] が指定されている場合は拒否されます。
//
// 各構造体フィールドの表現は、"json"構造体タグでカスタマイズできます。
// タグはカンマ区切りのオプションリストです。
// 特殊なケースとして、タグ全体が`json:"-"`の場合、
// そのフィールドはJSON表現上無視されます。
// 一部のオプションは呼び出し元が指定する [Options] によっても同等の挙動を制御できます。
// フィールド指定のオプションは呼び出し元指定のオプションより優先されます。
//
// 最初のオプションはGo構造体フィールドのJSONオブジェクト名の上書きです。
// 名前が指定されていない場合、Go構造体フィールド名がJSONオブジェクト名として使われます。
// カンマや引用符を含む名前、""や"-"と同じ名前は、
// Goの二重引用符文字列リテラルと同じ構文で、区切りを単一引用符にした
// 単一引用符文字列リテラルで指定できます。
// デフォルトでは、アンマーシャル時にJSONオブジェクト名とGo構造体フィールドの対応は
// 大文字・小文字を区別して一致判定されます。
//
// 名前の後には、以下のタグオプションがサポートされています。
//
//   - omitzero: マーシャル時に、"omitzero"オプションはフィールド値がゼロ値の場合に
//     フィールドを省略します。ゼロ値かどうかは "IsZero() bool" メソッドがあればそれで判定し、
//     なければGoのゼロ値かどうかで判定します。
//     このオプションはアンマーシャル時には効果がありません。
//
//   - omitempty: マーシャル時に、"omitempty"オプションはフィールド値が
//     JSON null、空文字列、空オブジェクト、空配列としてエンコードされる場合に
//     フィールドを省略します。
//     このオプションはアンマーシャル時には効果がありません。
//
//   - string: "string"オプションは [StringifyNumbers] をセットし、
//     構造体フィールド値のマーシャル・アンマーシャル時に数値型を
//     JSON文字列内のJSON数値としてエンコード・デコードします。
//     この追加のエンコードは、多くのJSONパーサが64ビット整数を正確に扱えないため
//     必要になることがあります。
//
//   - case: アンマーシャル時に、"case"オプションは
//     JSONオブジェクト名とGo構造体フィールドのJSON名の一致方法を指定します。
//     オプションは "case:value" のキー・バリュー形式で、値は 'ignore' または 'strict' です。
//     'ignore' は大文字・小文字を区別せず、ダッシュやアンダースコアも無視して一致判定します。
//     複数フィールドが一致した場合は幅優先順で最初のフィールドが優先されます。
//     'strict' は大文字・小文字を区別して一致判定します。
//     この指定は [MatchCaseInsensitiveNames] オプションより優先されます。
//
//   - inline: "inline"オプションは、このフィールド型のJSON表現内容を
//     親構造体に指定されたかのように昇格させます。
//     これはGoの構造体埋め込みのJSON版です。
//     Goの埋め込みフィールドは明示的なJSON名がなければ暗黙的にinlineされます。
//     inline対象はJSONメソッドを実装しないGo構造体、[jsontext.Value]、map[~string]T、またはそれらへの無名ポインタ型です。
//     マーシャル時、ポインタ型のinlineフィールドがnilなら省略されます。
//     [jsontext.Value] 型やmap[~string]T型のinlineフィールドは「インラインフォールバック」と呼ばれ、
//     親構造体で直接扱われないすべてのJSONオブジェクトメンバーを表現できます。
//     インラインフォールバックフィールドは構造体内に1つだけ指定でき、
//     非フォールバックフィールドは複数指定できます。
//     このオプションは他のオプション（JSON名含む）と併用できません。
//
//   - unknown: "unknown"オプションはインラインフォールバックの特殊なバリエーションで、
//     このGo構造体フィールドが任意数の未知のJSONオブジェクトメンバーを保持することを示します。
//     フィールド型は [jsontext.Value]、map[~string]T、またはそれらへの無名ポインタ型でなければなりません。
//     マーシャル時に [DiscardUnknownMembers] が指定されている場合、このフィールドの内容は無視されます。
//     アンマーシャル時に [RejectUnknownMembers] が指定されている場合、未知のオブジェクトメンバーは
//     "unknown"オプション付きインラインフォールバックの有無に関わらず拒否されます。
//     このオプションは他のオプション（JSON名含む）と併用できません。
//
//   - format: "format"オプションはフィールド値の書式指定フラグを指定します。
//     オプションは "format:value" のキー・バリュー形式で、
//     値は英数字のリテラル（例："format:RFC3339"）または単一引用符付き文字列リテラル
//     （例："format:'2006-01-02'"）です。
//     フォーマットフラグの解釈は構造体フィールド型によって決まります。
//
// "omitzero"と"omitempty"オプションは、ほぼ同じ意味を持ちます。
// 前者はGoの型システムに基づいて定義されており、
// 後者はJSONの型システムに基づいて定義されています。
// そのため、状況によって挙動が異なる場合があります。
// 例えば、"omitzero"ではnilのスライスやマップのみが省略されますが、
// "omitempty"ではnilかどうかに関係なく空のスライスやマップが省略されます。
// "omitzero"オプションは、明確なゼロ値を持つ型（例：[net/netip.Addr]）や
// IsZeroメソッドを持つ型（例：[time.Time.IsZero]）に便利です。
//
// すべてのGo構造体は、JSONで表現可能なフィールドのリストに対応します。
// このリストは、すべての構造体フィールド（非公開や無視されたフィールドを除く）に対して
// 幅優先探索を行い、探索はインライン構造体にも再帰的に降りていくことで構築されます。
// 構造体内のインラインでないフィールド集合は、ユニークなJSON名を持たなければなりません。
// 複数のフィールドが同じJSON名を持つ場合、最も浅い階層のフィールドが優先され、
// より深い階層のフィールドはJSON表現可能フィールドのリストから除外されます。
// 最も浅い階層で複数のフィールドが同じJSON名を持ち、
// そのうち1つだけが明示的にJSON名タグを持つ場合は、そのフィールドが優先され、
// 他のフィールドはリストから除外されます。
// これは、埋め込み構造体型のフィールド選択におけるGoの可視性ルールに類似しています。
//
// JSON表現可能なフィールドがない非空構造体をマーシャルまたはアンマーシャルすると
// [SemanticError] になります。
// 非公開フィールドには`json:"-"`以外の`json`タグを付けてはいけません。
//
// # Security Considerations
//
// JSONは、異なるシステム間（異なる言語で実装されている場合もある）で
// データ交換フォーマットとして頻繁に利用されます。
// 相互運用性やセキュリティの観点から、すべての実装が
// データのセマンティックな意味に合意することが重要です。
//
// [For example, suppose we have two micro-services.]
// 1つ目のサービスはJSONリクエストの認証を担当し、
// 2つ目のサービスは（前のサービスが認証したと仮定して）リクエストの実行を担当します。
// 攻撃者がJSONリクエストを巧妙に細工し、両サービスが同じリクエストを
// 異なるユーザーからのものと認識することができれば、
// 1人のユーザーの有効な認証情報で認証を通過し、
// 別のユーザーの権限で悪意ある操作を実行できてしまいます。
//
// RFC 8259によると、構文的には正しいが意味的に曖昧なJSONテキストが多数存在します。
// 例えば、標準ではオブジェクト内の重複した名前の解釈方法が定義されていません。
//
// v1の [encoding/json] とv2の [encoding/json/v2] パッケージは、
// 一部の入力を異なる方法で解釈します。特に：
//
//   - 標準ではJSONはUTF-8でエンコードされる必要があります。
//     デフォルトでは、v1はJSON文字列内の不正なUTF-8バイトを
//     Unicodeの置換文字に置き換えますが、v2は不正なUTF-8を含む入力を拒否します。
//     デフォルトを変更するには [jsontext.AllowInvalidUTF8] オプションを指定します。
//     不正なUTF-8の置換は、文字列の意味を変えてしまうデータ破損の一種です。
//
//   - 標準ではJSONオブジェクト内の重複した名前に対する特定の挙動は定義されていません。
//     そのため、実装ごとに挙動が異なる場合があります。
//     デフォルトでは、v1は重複した名前の存在を許容し、v2は重複した名前を拒否します。
//     デフォルトを変更するには [jsontext.AllowDuplicateNames] オプションを指定します。
//     許容した場合、オブジェクトメンバーは観測された順に処理され、
//     後の値が前の値を置換またはマージします（Go値の型による）。
//
//   - 標準ではJSONオブジェクトは名前と値のペアの順序なし集合と定義されています。
//     順序は基礎となる [jsontext] APIで観測できますが、
//     v1もv2も一般的には順序を公開しません。
//     アプリケーションはオブジェクトメンバーの順序に意味を持たせるべきではありません。
//     重複した名前を許容すると、順序に依存する挙動が偶発的に発生する可能性があります。
//
//   - 標準ではJSONオブジェクト名はUnicodeコードポイント列の等価性で比較されると示唆されています。
//     これは通常、大文字・小文字を区別する比較を意味します。
//     JSONオブジェクトをGo構造体にアンマーシャルする際、
//     デフォルトでv1は（緩い）大文字・小文字を区別しない一致判定を行い、
//     v2は（厳密な）大文字・小文字を区別する一致判定を行います。
//     デフォルトを変更するには [MatchCaseInsensitiveNames] オプションを指定します。
//     大文字・小文字を区別しない一致判定を許容すると、重複名が発生する可能性があり、
//     v1やv2が他の多くのJSON実装（通常は大文字・小文字を区別する）と異なる解釈をすることになります。
//
//   - 標準ではJSONオブジェクト内で未知の名前が現れた場合の挙動は定義されていません。
//     Go構造体へのアンマーシャル時、デフォルトでv1もv2も未知の名前と値を無視します。
//     デフォルトを変更するには [RejectUnknownMembers] オプションを指定します。
//
//   - 標準ではJSON数値の表現にfloat64を使うことができると示唆されています。
//     そのため、大きなJSON整数は浮動小数点型に格納すると精度を失う可能性があります。
//     v1もv2も具体的な整数型へのマーシャル・アンマーシャル時は精度を正しく保持します。
//     ただし、他のJSON実装がv1やv2の出力の精度を保持できるとは限りません。
//     `string`タグオプションを使うことで、整数型をJSON文字列で囲み、精度喪失を防げます。
//     また、v1やv2でもanyインターフェース値へのアンマーシャル時は
//     デフォルトでfloat64を使うため精度を失う場合があります。
//     デフォルトを変更するには [WithUnmarshalers] オプションで
//     精度を保持できる具体的なGo型を事前にインターフェース値へ設定するカスタムアンマーシャラを指定します。
//
// RFC 8785は、RFC 8259で未定義だった挙動を明確に定義した
// JSONテキストの正規形を規定しています。
// 理論的には、[jsontext.Value.Canonicalize] で意味を変えずに
// 正規化できるテキストは、より安全かつ相互運用性が高いと考えられます。
//
// v2 APIは一般的にv1より安全なデフォルトを選択しますが、
// 大きな整数や未知のメンバーには引き続き注意が必要です。
//
// [For example, suppose we have two micro-services.]: https://www.youtube.com/watch?v=avilmOcHKHE&t=1057s
package json
