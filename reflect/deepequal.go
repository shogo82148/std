// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// 反射を利用した深い等値のテスト

package reflect

// DeepEqualは、xとyが「深く等しい」という条件であるかどうかを報告します。
// 同一の型の2つの値は、次のどちらかの場合に深く等しいと見なされます。
// 異なる型の値は、決して深く等しくありません。
//
// 配列の値は、それぞれの要素が深く等しい場合に深く等しいと見なされます。
//
// 構造体の値は、対応するフィールド（公開されたものと非公開のもの）が深く等しい場合に深く等しいと見なされます。
//
// 関数の値は、どちらもnilの場合には深く等しく、それ以外の場合は深く等しくありません。
//
// インタフェースの値は、深く等しい具体的な値を保持している場合に深く等しいと見なされます。
//
// マップの値は、次のすべてが真である場合に深く等しいと見なされます：
// どちらもnilまたはどちらも非nilであり、長さが同じであり、
// 同じマップオブジェクトであるか、または対応するキー（Goの等値性を使用して一致する）が深く等しい値にマップされている場合。
//
// ポインタの値は、Goの==演算子を使用して等しければ、深く等しいと見なされます。
// または、深く等しい値を指している場合も深く等しくなります。
//
// スライスの値は、次のすべてが真である場合に深く等しいと見なされます：
// どちらもnilまたはどちらも非nilであり、長さが同じであり、
// 同じ基礎配列の同じ初期エントリを指しているか（つまり、&x[0] == &y[0]）または対応する要素（長さまで）が深く等しい場合。
// 非nilの空のスライスとnilのスライス（例：[]byte{}と[]byte(nil)）は深く等しくありません。
//
// 他の値 - 数値、ブール値、文字列、およびチャネル - は、Goの==演算子を使用して等しい場合に深く等しいです。
//
// 一般的には、DeepEqualはGoの==演算子の再帰的な緩和です。
// ただし、このアイデアは一貫性のないもので実装することは不可能です。
// 具体的には、値が自身に等しくない場合があります。
// これは、func型であるため（一般的には比較できない）または浮動小数点NaN値であるためです
// または、そのような値を含む配列、構造体、またはインタフェースであるためです。
// 一方、ポインタの値は常に自身に等しく、それらがまたはそのような問題のある値を指している場合でも等しいため、
// それらはGoの==演算子を使用して等しいため、その条件さえ満たせば、その内容に関係なく深く等しいと見なされます。
// DeepEqualは、同じスライスまたは同じマップである場合、
// コンテンツに関係なく深く等しいと見なされるように定義されています。
//
// DeepEqualはデータ値をトラバースする中で、サイクルを検出することがあります。
// DeepEqualが以前に比較したポインタの値を2回目以降比較するとき、それらを指す値を検査せずに等しいと見なします。
// これにより、DeepEqualが終了することが保証されます。
func DeepEqual(x, y any) bool
